<!--
Sync Impact Report:
Version: 1.1.0 → 1.2.0
Modified principles:
  - Principle III: テストファースト → 初期フェーズはE2E優先に更新
Added sections:
  - ブランチ戦略（Trunk-Based Development）
  - テスト層の方針詳細化
  - 実行ポリシー明記
  - Principle VIII: 独自性重視のフロントエンドデザイン（Anti-Generic UI）
Removed sections: N/A
Templates requiring updates:
  ✅ plan-template.md - Constitution Check section already present
  ✅ spec-template.md - User Scenarios & Requirements structure aligns with Principle I
  ✅ tasks-template.md - Test-first requirements align with Principle III
  ✅ CLAUDE.md - デザインガイドラインをconstitutionへ移行、参照に置き換え
Follow-up TODOs: None
-->

# YURUBO プロジェクト憲法

## Core Principles

### I. ストーリー駆動開発（User Story-First）

すべての機能実装はユーザーストーリーを中心に組織化されなければならない。

- 各ストーリーには受入シナリオ、バリデーションルール、エラーハンドリングを含む
- ストーリーは優先度付け（P1, P2, P3...）され、独立してテスト・実装可能である
- ストーリー単位でMVPを構成し、段階的な価値提供を実現する

**根拠**: ユーザー価値を中心に据えることで、技術的複雑性より価値提供を優先する。

### II. シンプルさ優先（YAGNI原則）

不要な抽象化・汎用化・将来の拡張を見越した設計は行わない。

- 最小構成で動く実装を構築する
- 機能フラグ、後方互換レイヤー、バージョン分岐は作成しない（未リリース段階）
- 複雑なオーケストレーションは延期する
- 「小さな関数を積み重ねる」哲学を採用する

**根拠**: 開発初期段階では効率を最大化し、冗長な実装や複雑な条件分岐を回避する。

### III. テストファースト（TDD推奨、初期フェーズはE2E優先）

すべての実装コードには対応するテストが必須である。

**Bottom-Up TDD Workflow**:
1. Phase 1: 要件理解
2. Phase 2: 単体テスト（RED → GREEN → REFACTOR）
3. Phase 3: 統合テスト
4. Phase 4: E2Eテスト（受入シナリオ全カバー）

**テスト層の方針**:
- **単体テスト（Jest + RTL）**: ロジック・小コンポーネント、状態変化やバリデーション
- **統合テスト（RTL）**: コンポーネント間連携、storeやhooks動作確認（状況に応じて）
- **E2Eテスト（Playwright）**: 画面操作〜API応答、UXと主要フロー保証

**実行ポリシー**:
- **PR作成時**: Lint + Unit Test（GitHub Actions自動実行）
- **mainマージ前 or 定期実行**: E2E（Playwright）を nightly で実行
- **初期フェーズ**: E2E優先で体験保証、Unit Testは段階的に追加

**根拠**: 初期段階ではE2E中心でユーザー体験を保証し、拡張フェーズで単体・統合テストを併用。テストファーストにより品質を保証し、リファクタリングを安全に行う。

### IV. 型安全性とバリデーション

TypeScript strict modeを使用し、型安全性を最大化する。

- Zodなどでバリデーションスキーマを定義する
- フロントエンドとバックエンドでスキーマを再利用する
- すべてのユーザー入力をバリデーションする

**根拠**: 実行時エラーを最小化し、開発者体験を向上させる。

### V. 統一されたエラーハンドリング

すべてのAPIレスポンスは統一された形式に従う。

```typescript
// 成功時
{ success: true, message: '成功メッセージ', code: 'SUCCESS_CODE' }
// エラー時
{ success: false, message: 'エラーメッセージ', code: 'ERROR_CODE' }
```

- エラーメッセージは日本語で明確に記述する
- 一時的な障害にはリトライロジックを実装する
- エラーをログに記録する

**根拠**: 一貫したエラーハンドリングにより、フロントエンドでの処理を簡素化する。

### VI. AI補助の原則（提案まで、確定は人間）

AIは候補提示・段取り整理までを担当し、確定操作は必ず人間が行う。

- AIは店舗候補・日程候補などを提示する
- 店舗予約・決済・契約操作は自動化しない
- 承認・拒否などの意思決定は人間が行う

**根拠**: プロダクト設計哲学「AIが段取りを整え、人が決める」に基づく。

### VII. 学習補助モード（Comment-First）

すべての実装コードには学習補助を目的とした詳細な日本語コメントを必ず含める。

**コメント記述要件**:
1. **ファイル全体のコメント（ファイル冒頭）**: 概要、処理フロー、主要機能、依存関係
2. **処理単位のコメント（関数・コンポーネント単位）**: パラメータ、戻り値、処理内容、使用例
3. **ロジック内のインラインコメント**: 文法説明、処理の意図、エッジケース対応

**エラー連続時の対応**:
- 同じエラーが2回以上連続した場合、ユーザーに修正方針を提示し判断を待つ
- エラー分析結果（内容、原因、影響範囲）と複数の修正案（メリット・デメリット）を提示
- 自動的に修正を試みず、ユーザーの選択を待つ

**根拠**: コード内学習により、開発者のスキル向上とコードの可読性を同時に実現する。

### VIII. 独自性重視のフロントエンドデザイン（Anti-Generic UI）

AIが生成しがちな画一的・汎用的なUIを回避し、プロダクショングレードの独自性あるインターフェースを構築する。

**デザイン思考プロセス（実装前に必須）**:
1. **目的**: このUIは何を解決するか？誰が使うか？
2. **トーン**: 大胆な美的方向性を選択する
   - ミニマル、マキシマリスト、レトロフューチャリスティック、オーガニック、ラグジュアリー、遊び心、エディトリアル、ブルータリスト、アールデコ、ソフト/パステル、インダストリアルなど
   - YURUBOの場合：親しみやすさ・カジュアルさ・使いやすさを基調としつつ、独自の美的方向性を追求
3. **制約**: 技術要件（Next.js、Tailwind、shadcn-ui、パフォーマンス、アクセシビリティ）
4. **差別化**: このプロダクトを記憶に残すものは何か？
5. **批判的思考**: 明確なコンセプトの方向性を定め、それを正確に実行する

**美的ガイドライン（必須）**:

| 要素 | 方針 |
|------|------|
| **タイポグラフィ** | 個性的で興味深いフォントを選択。Inter、Roboto、Arial、システムフォントは禁止。ディスプレイ用と本文用を使い分ける |
| **色とテーマ** | 統一感のある美しいデザイン。CSS変数で一貫性を保つ。アクセントカラーを効果的に際立たせる |
| **モーション** | ページ読み込み時の段階的アニメーション、ホバー・スクロールトリガーなど。CSSソリューション優先、必要に応じてframer-motion |
| **空間構成** | 予想外のレイアウト、非対称性、重なり、豊かなネガティブスペース、制御された密度 |
| **背景とビジュアル** | 単色統一を避け、雰囲気と奥行きを演出。グラデーション、ノイズテクスチャ、幾何学模様、レイヤー効果など |

**禁止事項（Anti-Generic）**:
- ❌ 汎用フォント（Inter、Roboto、Arial、システムフォント）
- ❌ 決まりきった配色（白背景 + 紫グラデーションなど）
- ❌ 予測可能なレイアウトとコンポーネントパターン
- ❌ コンテキスト固有の特性が欠如した型どおりのデザイン
- ❌ 世代を超えて同じ選択に収束すること（例：Space Grotesk）

**実装の複雑さとビジョンの一致**:
- マキシマリスト的デザイン → 精巧なコード、豊富なアニメーション・エフェクト
- ミニマリスト的デザイン → 抑制、精密さ、スペース・タイポグラフィへの細心の注意
- エレガントさはビジョンを正確に実現することで生まれる

**技術スタック別ガイドライン**:
- **Tailwind CSS**: ユーティリティファースト、カスタムカラーは`tailwind.config.ts`で定義
- **shadcn-ui**: 基本コンポーネントとして活用、YURUBOの雰囲気に合わせてカスタマイズ
- **Next.js**: Server Components優先、`next/image`で最適化、`next/font`でフォント読み込み

**実装チェックリスト**:
- [ ] アクセシビリティ（WAI-ARIA、キーボード操作）
- [ ] レスポンシブデザイン（モバイル、タブレット、デスクトップ）
- [ ] パフォーマンス（不要な再レンダリング回避）
- [ ] 一貫性（既存UIとの整合性）
- [ ] E2Eテスト（`data-testid`属性の設定）

**根拠**: 独自性のあるUIはユーザー体験とブランド価値を高め、プロダクトを記憶に残るものにする。

## 開発ワークフロー

### ブランチ戦略（Trunk-Based Development）

**基本方針**:
- Trunk-Based Development を採用
- `main` ブランチは常に動作保証された状態を維持
- すべての変更は PR 経由で `main` に統合（直接 push 禁止）
- Claude / Cursor のセッション単位で責務を分離し、各自専用ブランチで作業

**ブランチ命名規則**:
- **機能開発（ユーザーストーリー単位）**: `feature/{3桁数字}-{機能名}`
  - 例: `feature/001-event-creation`, `feature/000-phase2-foundation`
  - 数字はspecs/ディレクトリと対応（SpecKit機能の場合）
  - Phase/基盤構築も数字プレフィックスで管理（例: 000番台）
  - **1ストーリー = 1ブランチ = UI + API + テスト全部含む**
- 環境構築: `infra/<対象>` 例: `infra/setup-ci`
- バグ修正: `fix/<内容>` 例: `fix/ui-modal-close`
- リファクタ: `refactor/<範囲>` 例: `refactor/event-schema`
- 実験／検証: `exp/<内容>` 例: `exp/claude-prompt-tuning`

**運用ルール**:
- 1つのブランチは「1ユーザーストーリー完結」に対応
- UI/API分割せず、1ストーリーを1ブランチで完結させる
- 作業時間の目安: 1〜3時間〜半日で完了できる粒度
- 作業終了後、PRを作成しCI通過後に`main`へマージ
- マージ後はブランチ自動削除（GitHub設定推奨）

**並行開発戦略**:
- **依存のないストーリー同士は並列開発OK**
  - 例: `feature/001-event-creation` と `feature/002-timeline-view` を同時着手
- **依存のあるストーリーは前のストーリーのmainマージを待つ**
  - 例: `003-event-edit` は `001-event-creation` のマージ後に着手
- 各セッションは独立したストーリー番号で作業
- main更新後は各ブランチで `git pull origin main` を行い、差分を早期吸収

**アンチパターン（禁止）**:
❌ 同一ストーリーをUI/APIで分割（例: `001-ui-xxx`, `001-api-xxx`）
  → SpecKitスクリプトが競合し、spec.md編集が衝突する

### SpecKitワークフロー（必須）

新機能実装時は必ずSpecKitワークフローに従う。仕様フェーズをスキップしない。

1. `/speckit.specify` - 自然言語から機能仕様を作成
2. `/speckit.clarify` - 仕様の曖昧な部分を質問
3. `/speckit.plan` - 設計成果物と実装計画を生成
4. `/speckit.tasks` - 依存関係順のタスクリスト生成
5. `/speckit.implement` - タスクを処理して実装
6. `/speckit.analyze` - 成果物間の整合性分析
7. `/speckit.checklist` - 機能固有チェックリスト生成

テンプレートは`.specify/templates/`を使用する。

### タスク完了の定義（Definition of Done）

- Phase 2: 単体テスト作成済み、すべてパス
- Phase 3: 統合テスト作成済み、すべてパス
- Phase 4: E2Eテスト作成済み、受入シナリオ全カバー
- 型エラーなし
- リントエラーなし

## Quality Gates

### 応答言語・コーディング規約

- 応答言語: 日本語
- コードコメント: すべて日本語で記述
- 技術用語: 英語のまま使用可（例: Server Components, Props）
- 変数名・関数名: 英語（言語規約に従う）

### 実行環境制約

- Python等のランタイムコードを実行しない
- 静的なコード例・疑似コード・構造の説明を優先
- ファイル操作、環境変数、パッケージインストールなど実行環境依存処理は記述しない
- 「実行した場合の推定結果」提示も行わない

### 応答ポリシー

- 不明点は推測せず、必要な情報を明確に質問する
- 問題解決に関係のない文言（雑談・感謝など）は含めない
- 回答は質問内容に直接関連したものに限定、冗長な文章を避ける

## Governance

### 憲法の位置づけ

この憲法はすべての開発プラクティスに優先する。

### 修正手続き

憲法の修正には以下が必要である:
- 修正提案の文書化
- 影響を受けるテンプレート・ドキュメントの特定
- 移行計画の策定
- セマンティックバージョニングに基づくバージョン更新

### バージョニングポリシー

- **MAJOR**: 後方互換性のないガバナンス/原則の削除または再定義
- **MINOR**: 新しい原則/セクションの追加または大幅な拡張
- **PATCH**: 明確化、文言修正、タイポ修正、非意味的な改善

### コンプライアンスレビュー

すべてのPR・レビューはこの憲法への準拠を検証しなければならない。
複雑性は正当化されなければならない。
実行時の開発ガイダンスは`CLAUDE.md`を参照する。

**Version**: 1.2.0 | **Ratified**: 2025-11-11 | **Last Amended**: 2025-12-03

<!--
Version 1.2.0 Change Log:
- Added: Principle VIII - 独自性重視のフロントエンドデザイン（Anti-Generic UI）
- Migrated: CLAUDE.mdのデザインガイドラインを憲法へ統合

Version 1.1.0 Change Log:
- Added: ブランチ戦略（Trunk-Based Development）セクション
- Modified: テストファースト原則を「初期フェーズはE2E優先」に更新
- Added: テスト層の方針（Unit / Integration / E2E）詳細化
- Added: 実行ポリシー（PR時/nightly実行）明記
-->
