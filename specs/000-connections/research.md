# Research: つながり管理（Connections）

**Feature**: Epic 000 - つながり管理
**Date**: 2025-12-03
**Status**: Completed

## 1. 技術調査結果

### 1.1 既存インフラストラクチャ

**調査結果**: 既存のデータベーススキーマとサービスを確認

| 項目 | 現状 | 判断 |
|------|------|------|
| connections テーブル | 既存（category_flags JSONB型） | 拡張が必要 |
| users テーブル | 既存（enabled_categories配列） | そのまま利用可能 |
| categories テーブル | 既存（drinking, travel, tennis, other） | そのまま利用可能 |
| connection.service.ts | 基本的なgetConnectionCountのみ | 大幅拡張が必要 |

**決定**: 既存のテーブル構造を活かしつつ、つながりリクエスト機能を新規追加

### 1.2 つながりリクエスト管理

**課題**: 現在のconnectionsテーブルはリクエスト状態（pending）を管理していない

**検討した選択肢**:

| 選択肢 | メリット | デメリット |
|--------|----------|------------|
| A: connectionsにstatus列追加 | シンプル、既存構造活用 | pending/activeの混在で複雑化 |
| B: connection_requests新規テーブル | 責務分離、クリーンな設計 | テーブル増加、JOIN増 |
| C: statusとexpires_at列追加 | 期限管理も一元化 | 既存データへの影響 |

**決定**: 選択肢B - connection_requestsテーブルを新規作成

**根拠**:
- つながりリクエストは「承認待ち状態」であり、成立したつながりとは別概念
- リクエストには有効期限（7日）があり、自動削除のトリガーが必要
- 同時リクエスト検出（A→B、B→A）の処理が明確になる
- YAGNI原則に反しない最小限の拡張

### 1.3 カテゴリ設定の双方向性

**調査結果**: spec.md US3のシナリオ4で双方向チェックが要求されている

**現状の理解**:
- Aさんが設定する「Bさんとの飲みカテゴリ」= AさんがBさんの飲みイベントを受信したいかどうか
- Bさんが設定する「Aさんとの飲みカテゴリ」= BさんがAさんの飲みイベントを受信したいかどうか
- イベント配信時は「投稿者が対象者を許可 AND 対象者が投稿者を許可」の両方が必要

**決定**: 双方向チェックロジックはイベント配信時（Epic 001連携時）に実装

### 1.4 ユーザー検索機能

**調査結果**: usersテーブルにdisplay_nameインデックスが存在

**検討した選択肢**:

| 選択肢 | メリット | デメリット |
|--------|----------|------------|
| A: LIKE検索（display_name） | シンプル、既存インデックス活用 | 部分一致のみ、パフォーマンス懸念 |
| B: 全文検索（pg_trgm） | 柔軟な検索、タイポ許容 | 設定複雑、初期段階では過剰 |
| C: display_name + id検索 | spec要件を満たす | 十分 |

**決定**: 選択肢C - display_nameとidの両方で検索可能に

**根拠**: spec.md FR-001「ユーザー名またはIDによる友人検索」を満たす最小実装

### 1.5 通知機能

**調査結果**: usersテーブルにnotification_preferences（JSONB）が存在

**決定**:
- アプリ内通知を基本とする
- notificationsテーブルを新規作成（未読/既読管理）
- 将来のメール・プッシュ通知拡張を考慮した設計

### 1.6 自分が設定したカテゴリのみ表示

**spec.md US3 要件**: 自分が設定したカテゴリのみチェックボックスとして表示

**調査結果**: usersテーブルのenabled_categories配列で管理

**決定**:
- つながり編集画面では、自分のenabled_categoriesに含まれるカテゴリのみ表示
- 相手のenabled_categoriesは参照しない（プライバシー保護）

## 2. 技術的決定事項

### 2.1 新規テーブル

| テーブル名 | 用途 |
|-----------|------|
| connection_requests | つながりリクエスト管理（pending状態） |
| notifications | アプリ内通知管理 |

### 2.2 既存テーブル変更

| テーブル名 | 変更内容 |
|-----------|----------|
| connections | 変更なし（既存構造を活用） |
| users | 変更なし |
| categories | 変更なし |

### 2.3 API設計方針

| 機能 | 実装方式 |
|------|----------|
| ユーザー検索 | Server Actions（app/actions/） |
| リクエスト送信/承認/拒否 | Server Actions |
| つながりリスト取得 | Server Actions + Supabase RLS |
| カテゴリ設定 | Server Actions |
| 通知取得 | Server Actions |

**根拠**: 既存のapp/actions/構造に従い、一貫性を保つ

### 2.4 リクエスト期限切れ処理

**検討した選択肢**:

| 選択肢 | メリット | デメリット |
|--------|----------|------------|
| A: Supabase Edge Functions（cron） | 自動実行、確実 | 設定複雑 |
| B: PostgreSQL pg_cron | DB内完結 | Supabase対応要確認 |
| C: アクセス時に期限切れチェック | シンプル、追加設定不要 | 期限切れデータが残る |

**決定**: 選択肢C - アクセス時に期限切れチェック（初期実装）

**根拠**:
- MVP段階ではシンプルな実装を優先
- 期限切れリクエストはUIで非表示にし、定期的なDBクリーンアップは将来対応

## 3. リスクと軽減策

| リスク | 影響度 | 軽減策 |
|--------|--------|--------|
| 同時リクエストの競合 | 中 | DBトランザクションで排他制御 |
| つながり数上限なし | 低 | パフォーマンス監視、必要に応じて上限設定 |
| 通知の遅延 | 低 | アプリ内通知のみのため影響小 |

## 4. 未解決事項

なし（全ての不明点を解消）
